Title: The Complexity of Perl
Topic: Perl::Metrics::Simple
Author: Dave Cross <dave@perlhacks.com>

=head1 The Complexity of Perl

When you're writing code, one of your goals should be to make your code as
simple as possible. It seems self-evident that simple code will be easier
to understand and easier to maintain and will therefore contain fewer bugs
than complex code.

Of course, we want to write software that does complex things. And this
apparent paradox is easy enough to resolve. We just need to create a lot
of very simple software and join it together in complex ways.

But what constitutes "complex code"? Can we measure the complexity of an
arbitrary piece of code? And what level of complexity should we be aiming at?

Luckily for us, this is a solved problem. Back in 1976 Thomas J. McCabe
came up with the idea of "cyclometric complexity". McCabe's idea was to
measure the complexity of a piece of code by counting the number of possible
execution paths that can be traced through the code.

Let's look at this with an example. Here's some arbitrary Perl code:

    sub foo {                               # 1: for non-empty code
        if ( @list ) {                      # 1: "if"
            foreach my $x ( @list ) {       # 1: "foreach"
                if ( ! $x ) {               # 2: 1 for "if" and 1 for "!"
                    do_something($x);
                }
                else {                      # 1 for "else"
                    do_something_else($x);
                }
            }
        }
        return;
    }

This code has a complexity of 6. This is made up from the following elements:

=over 4

=item * 1 for having some code in the subroutine

=item * 1 for the first 'if' statement

=item * 1 for the 'foreach' statement

=item * 1 for the second 'if' statement

=item * 1 for the '!' in the second 'if' statement

=item * 1 for the 'else' statement

=back
