Author: Sawyer X <xsawyerx@cpan.org>
Title: The Night Before Deployment: How Melian Saved Christmas (and How It Can Speed Up Your App Too)
Topic: Blazingly fast caching server

=pod

=encoding utf8

    It was the night before deployment,
    and all through the North Pole,
    not a dashboard was green,
    not a query was whole.

December 23rd is the annual I<Mega Load Test> for the Christmas Eve delivery system. Every service (the Toy Inventory API, the Naughty-or-Nice Scoring Engine, the Elf Logistics Portal) suddenly wakes up to millions of requests. And every year, something new falls over.

This year, it was the B<Toy Service>.

At 16:04, an alert fired:

    "Average latency > 2000ms on SELECT toy WHERE id=...."

At 16:05, another:

    "Database CPU 100%. Replica lag increasing. Costs spiking."

By 16:06:

    "SLEIGH ETA CANNOT BE COMPUTED. CHRISTMAS IN JEOPARDY."

Elves ran around in chaos. Santa sipped his cocoa with growing concern. Someone suggested buying a larger RDS instance until after Christmas, but the last time they did so, Finance needed I<six months> to recover.

=head2 üéÅ "Why are these C<SELECT>s so slow?" cried an elf.

The Senior SRE Elf adjusted his tiny glasses. "C<SELECT>s aren't slow," he explained. "We just run B<too many> of them. Thousands per second. Most ask for data that hasn't changed in weeks. The database is spending all its time doing unnecessary work. We're melting our own servers!"

Another elf waved a stack of sticky notes. "I told you we should cache it I<inside> the Toy Service! Just store the toys hash in memory!"

The SRE Elf shook his head. "We tried that last year. Remember the disaster? Every app instance kept its own copy, different instances refreshed at different times, some toy names were up-to-date, others were from 2018, every instance restart dogpiled the DB, deployments caused mass reload storms, memory bloat everywhere, and no central control."

"We can't fix a distributed caching problem by scattering more distributed caches across the fleet," he said gently. The Elf in Charge of Sticky Notes began quietly eating his notes in shame.

Another elf jumped in. "We could use Redis! At least that's centralized."

"Better," said the SRE Elf, "but Redis still puts pressure on our infra. And storing ten or twenty entire tables that elves query thousands of times per second? We'll need a large Redis cluster, which means larger AWS bills, and not the fun kind with reindeer on them."

The room fell silent. Santa tapped his mug. "We need something faster," he rumbled, "and something cheaper."

=head2 üéÑ The Ancient Scroll

At this, the Senior SRE Elf's face lit up. "There I<is> something... something old. Something powerful."

He ran to the dusty archives and dragged out an ancient scroll titled: B< "MELIAN: Keeper of Rapid Knowledge, Maia of Snapshots and Speed." >.

He unrolled it.

"It's a tiny server that loads whole or partial tables into memory," he explained.
"It refreshes them in the background, using a snapshot model - zero locking, no race conditions. It serves lookups in microseconds. We offload millions of C<SELECT>s from our database. Capacity costs drop instantly."

The elves gasped. "Does it work with our stack?"

"It speaks a simple protocol and already has clients in C, Perl, Python, PHP, and Node.js. Even better - L<Melian> is already on CPAN!"

One elf whispered: "Faster than Redis... cheaper than scaling up the DB... and simpler than fixing our app caching disaster... Santa, this could work!"

Santa smiled. "Then bring forth this Melian. Christmas depends on it."

=head2 ‚ú® Deployment at the North Pole

They configured Melian with a few environment variables:

=over 4

=item * Which database to load from (MySQL/Postgres/SQLite)

=item * Which tables, which indexes to search on

=item * How often to refresh the tables

=back

And then, on a snowy December evening, they launched it.

Immediately, Toy Service queries went from:

=over 4

=item * B<< 400 milliseconds ‚Üí around 10 microseconds >>

=item * Database CPU dropped like a sleigh down a steep hill

=item * AWS costs flattened

=item * Replica lag disappeared

=item * Dashboards turned green once again

=back

Santa clapped. "We've saved Christmas AND our budget!"

But the Senior SRE Elf wasn't done. He added one more twist.

"Since Melian can serve I<derived> tables, we don't have to reshape the database. For example, instead of querying C<toys_by_id>, we can create a computed view C<toys_by_person_id> or any other ephemeral materialization. Melian doesn't care whether the table exists physically. It just stores the results of whatever C<SELECT> we give it."

Suddenly, the elves realized the power they held. "This is... this is beautiful," whispered the Sticky-Note Elf.

=head1 üéÅ And Now: How You Can Use Melian

While the elves used Melian to rescue Christmas, B<you> don't need a sleigh-scale workload to benefit from it.

Maybe you have:

=over 4

=item * A personal dashboard

=item * A local inventory

=item * A home-lab metadata list

=item * A script that needs lightning-fast lookups

=item * A SQLite file you query too often

=back

Let's walk through a simple real-world setup you can use I<today>. And with this knowledge, you might be able to use Melian at work I<tomorrow>.

For this example, we'll build a small B<Gift Tracker> backed by SQLite.

=head2 üéÑ Step 1: Create a Tiny SQLite Database

    #!vim sql
    CREATE TABLE gifts (
        id        INTEGER PRIMARY KEY,
        recipient TEXT,
        gift      TEXT,
        price     INTEGER
    );

    INSERT INTO gifts VALUES
     (1, 'Alice', 'Warm socks', 12),
     (2, 'Bob', 'Lego spaceship', 59),
     (3, 'Eve', 'Noise-cancelling earplugs', 18);

Save it as: C</tmp/gifts.db>, though a more production-friendly location
would be C</var/db/melian/gifts.db> or using MySQL/MariaDB/PostreSQL.

=head2 üéÑ Step 2: Configure Melian

Instead of a config file, we will use environment variables:

    #!vim bash
    # What backend we use? sqlite/mysql/postgresql
    export MELIAN_DB_DRIVER=sqlite

    # Where is the SQLite DB file located?
    export MELIAN_SQLITE_FILENAME=/tmp/gifts.db

    # Define a single table with two indexes:
    export MELIAN_TABLE_TABLES="gifts#1|60|id#0:int;recipient#1:string"

The C<MELIAN_TABLE_TABLES> means:

=over 4

=item * The table is named C<gifts>

=item * It's idenitfied with the ID C<1> (we could pick any number)

=item * It refreshes every B<60 seconds>

=item * It has two indexes:

=over 4

=item * C<id> (integer type for integer lookup)

=item * C<recipient> (string type for string lookup)

=back

=back

=head2 üéÑ Step 3: Start Melian

    #!vim bash
    melian-server

By default, it listens the UNIX socket C</tmp/melian.sock>.

You can configure it to use a hostname and port, but a UNIX socket is the fastest by far.

=head2 üéÑ Step 4: Query Melian from Perl

I<(Yes, the elves use Perl too - it's very popular north of 89¬∞ latitude.)>

    #!vim perl
    use v5.34;
    use Melian;

    my $client = Melian->new( path => '/tmp/melian.sock' );

    # Fetch by numeric key: table 'gifts', column 'id', key '2'
    my $gift = $client->fetch_by_int_from( 'gifts', 'id', 2 );
    say "Gift for $gift->{recipient}: $gift->{gift} (‚Ç¨$gift->{price})";

    # Fetch by string key: table 'gifts', column 'recipient', key 'Bob'
    my $bob = $client->fetch_by_string_from( 'gifts', 'recipient', 'Bob' );
    say "Found Bob's gift: $bob->{gift}";

And the result:

    Gift for Bob: Lego spaceship (‚Ç¨59)
    Found Bob's gift: Lego spaceship

These lookups usually complete in B<single-digit microseconds>.

=for :html
  <center><img src="melian-demo.gif" alt="Melian demo"></center>

There are additional ways to use L<Melian> that make it faster and faster:

=over 4

=item *

Storing the IDs of the tables and columns to avoid Melian having to resolve them.

=item *

Using the functional interface, cutting down the cost of object-oriented in Perl.

=back

=head2 üéÑ Bonus: Ephemeral Derived Tables

Remember how the elves created a temporary table like C<toys_by_person_id>?

You can do that too:

    #!vim bash
    export MELIAN_TABLE_SELECTS="gifts=SELECT person_id, gift FROM gifts JOIN persons USING (id)"

Melian doesn't require the table to exist physically ‚Äî it just needs a C<SELECT> that returns rows.

This lets you use Melian as a B<lightweight materialization layer> without touching your source schema.

=head1 ‚òï Wrapping Up (with Cocoa)

That night, as the Toy Service hummed at 95,000 requests per second and the database rested peacefully for the first time in years, Santa lifted his mug and declared:

    "Let this be a lesson to all of us:
    Sometimes the fastest way to scale a system is to stop asking the database unnecessary questions."

Melian didn't just save Christmas. It saved capacity, money, performance, and developer sanity.

And who knows? Maybe it can do the same for your next project, festive or not.

Happy Holidays, and happy hacking! üéÖ‚ú®

=head1 References

=over 4

=item * L<Melian server|https://github.com/xsawyerx/melian>

=item * L<Melian Perl client|https://metacpan.org/pod/Melian>

=back
