Author: Sawyer X <sawyer.x@gmail.com>
Title: Sleigh Bells and Custom Ops
Topic: Ref::Util

=pod

=encoding utf8

=head1 Sleigh Bells and Custom Ops: A Jolly Journey with Ref::Util

Ho ho ho! ğŸ… As the festive season wraps us in its warm embrace, let's unwrap a shiny gift for Perl developers that's been nestled under the tree for a few years now: L<Ref::Util>. Just like how some of the best presents are hidden in plain sight, L<Ref::Util> brings a sprinkle of efficiency and clarity to our code, turning "naughty" reference checks into "nice" ones. So grab a mug of hot cocoa, and let's dive into this yuletide tale!

=head2 The Ghost of Reference Checks Past ğŸ

In the days of yore, you might have found yourself writing code like:

    if ( ref $sleigh eq 'HASH' ) {
        load_presents($sleigh);
    }

But alas! This is like finding coal in your stocking. ğŸ„ By using C<ref $sleigh eq 'HASH'>, we're peeking behind the curtains, exposing Perl's internal workings. We're grabbing the string representation of a reference and hoping it matches our expectations. If C<$sleigh> isn't a reference at all, C<ref> returns an empty string â€” leaving us out in the cold. (At least it's not C<undef>, which would likely wreak havoc during runtime).

=head2 Unwrapping Ref::Util âœ¨

Enter L<Ref::Util>, our festive hero that's been around for a while but might not have made it onto your wish list yet! With it, we can rewrite our code as:

    use Ref::Util qw< is_hashref >;

    if ( is_hashref($sleigh) ) {
        load_presents($sleigh);
    }

Isn't that as refreshing as a winter's first snow? â„ï¸  The code is cleaner and more readable, but the true magic lies beneath the surface. L<Ref::Util> doesn't just sprinkle a bit of tinsel on your code â€” it B<supercharges> it!

But wait, there's more under the tree! L<Ref::Util> provides a sleigh full of functions to check all sorts of references:

=over 4

=item *

C<is_ref($variable)>

=item *

C<is_scalarref($variable)>

=item *

C<is_arrayref($variable)>

=item *

C<is_hashref($variable)>

=item *

C<is_coderef($variable)>

=item *

C<is_regexpref($variable)>

=item *

C<is_globref($variable)>

=item *

C<is_formatref($variable)>

=item *

C<is_ioref($variable)>

=item *

C<is_refref($variable)>

=back

And their C<is_plain_*> and C<is_blessed_*> counterparts.

This comprehensive suite lets you check for any type of reference without exposing Perl's internals, making your code more robust and intention-revealing.

Example:

    use Ref::Util qw< is_blessed_arrayref >;

    if ( is_blessed_arrayref($elves) ) {
        assign_tasks($elves);
    }

Instead of:

    use Scalar::Util qw< blessed reftype >;
    if ( ref_type($elves) eq 'ARRAY' && blessed($elves) ) {
        assign_tasks($elves);
    }

(You might consider calling C<blessed($elves) eq 'ARRAY'> but that doesn't differentiate between package name and reference type.)

=head2 Performance: The Gift That Keeps on Giving ğŸ

Now, you might be thinking, "Sure, the code looks nicer, but is that all?" Oh, dear reader, the true magic lies in the B<massive speed improvements>! L<Ref::Util> doesn't just make your code more readable â€” it makes it B<faster>.

Let's peek into Santa's workshop and look at some benchmarks:

    ref():                                   5.335e+00 +/- 1.8e-02 (0.3%)
    ref(), reftype(), !blessed():            1.5545e+01 +/- 3.1e-02 (0.2%)
    Ref::Util::is_plain_arrayref (CustomOP): 2.7951e+00 +/- 6.2e-03 (0.2%)
    Data::Util::is_array_ref:                5.9074e+00 +/- 7.5e-03 (0.1%)

As you can see, C<Ref::Util::is_plain_arrayref> using Custom Ops is nearly B<twice as fast> as C<ref()> (2.7951 vs. 5.335 seconds) and more than B<five times faster> than combining C<ref()>, CScalar::Util::reftype(), and C<blessed()> checks (2.7951 vs. 15.545 seconds). It's like upgrading from a hand-drawn sleigh to a rocket-powered one! ğŸš€

=head2 Elves Under the Hood: The Magic of Op Codes ğŸ§™â€â™€ï¸

So, how does L<Ref::Util> achieve this festive feat? It's all thanks to some Christmas magic called B<Custom Ops>, introduced in Perl B<5.14> (released in 2011). Let's unwrap this concept together.

=head3 What Are Op Codes and the Optree?

In Perl, your code gets compiled into a tree of operations called the B<optree>. Each operation (B<op>) represents a fundamental action, like addition, subtraction, or fetching a variable. Think of it as the assembly instructions for Santa's elves.

=head3 The Traditional Method's Optree

When you write:

    if ( ref $sleigh eq 'HASH' ) {
        load_presents($sleigh);
    }

    7  <@> leave[1 ref] vKP/REFC ->(end)
    1     <0> enter v ->2
    2     <;> nextstate(main 1 -e:1) v:{ ->3
    -     <1> null vK/1 ->7
    6        <|> and(other->7) vK/1 ->7
    5           <2> seq sK/2 ->6
    -              <1> ex-rv2sv sK/1 ->4
    3                 <#> gvsv[*sleigh] s ->4
    4              <$> const[PV "HASH"] s ->5
    -           <@> scope vK ->7
    -              <;> ex-nextstate(main 3 -e:1) v ->-
    -              <0> ex-const v ->-

This involves multiple ops: fetching the variable, getting its reference type as a string, and then comparing that string.

=head3 Scalar::Util's C<reftype> Optree

Using L<Scalar::Util>'s C<reftype>

    use Scalar::Util 'reftype';

    if ( reftype($sleigh) eq 'HASH' ) {
        load_presents($sleigh);
    }

Generates an optree involving a function call:

    a  <@> leave[1 ref] vKP/REFC ->(end)
    1     <0> enter v ->2
    2     <;> nextstate(main 1 -e:1) v:{ ->3
    -     <1> null vKP/1 ->a
    9        <|> and(other->a) vK/1 ->a
    8           <2> seq sK/2 ->9
    6              <1> entersub[t1] sKS/TARG ->7
    -                 <1> ex-list sK ->6
    3                    <0> pushmark s ->4
    -                    <1> ex-rv2sv sKM/1 ->5
    4                       <#> gvsv[*sleigh] s ->5
    -                    <1> ex-rv2cv sK/1 ->-
    5                       <#> gv[*reftype] s ->6
    7              <$> const[PV "HASH"] s ->8
    -           <@> scope vK ->a
    -              <;> ex-nextstate(main 3 -e:1) v ->-
    -              <0> ex-const v ->-

This involves more ops due to the subroutine call to C<reftype>, adding overhead.

=head3 Ref::Util with Custom Ops

With L<Ref::Util> on Perl B<5.14> or newer, and when using a version of L<Ref::Util> that supports Custom Ops, you can write:

    use Ref::Util qw( is_hashref );

    if ( is_hashref($sleigh) ) {
        load_presents($sleigh);
    }

    6  <@> leave[1 ref] vKP/REFC ->(end)
    1     <0> enter v ->2
    2     <;> nextstate(main 1 -e:1) v:{ ->3
    -     <1> null vKP/1 ->6
    5        <|> and(other->6) vK/1 ->6
    4           <1> is_hashref sK/1 ->5
    -              <1> ex-rv2sv sKM/1 ->4
    3                 <#> gvsv[*sleigh] s ->4
    -           <@> scope vK ->6
    -              <;> ex-nextstate(main 3 -e:1) v ->-
    -              <0> ex-const v ->-

Notice how C<is_hashref> becomes a single op in the optree, even named C<is_hashref>. This Custom Op directly checks the reference type at the opcode level, eliminating unnecessary steps.

=head3 How Does This Magic Happen?

=over 4

=item *

B<Custom Ops Implementation (Fastest)> ğŸ…

When available, L<Ref::Util> uses B<Custom Ops> written in C (using XS). These are new operations added directly into Perl's optree, resulting in minimal overhead and maximal speed. It's like giving the elves new, more efficient tools.

=item *

B<XS Implementation (Fast)> ğŸ¦Œ

If Custom Ops aren't available (due to an older Perl version or limitations in the environment), L<Ref::Util> gracefully falls back to an XS implementation without Custom Ops. This means the functions are still written in C for performance but are called as regular functions. It's still faster than pure Perl but not as swift as using Custom Ops.

=item *

B<Pure-Perl Implementation> ğŸ›·

When neither Custom Ops nor XS implementations are available (such as on systems without a C compiler), L<Ref::Util> provides a pure-Perl fallback. This version has similar performance to the traditional method but retains the benefits of cleaner syntax and abstraction.

=back

=head2 The Spirit of the Season: Cleaner and Faster Code ğŸ…

Beyond performance, L<Ref::Util> embodies the true spirit of the holidays â€” making things better for everyone. By using functions like C<is_hashref>, C<is_arrayref>, C<is_coderef>, et. al., our code becomes more expressive and intention-revealing. It's easier for others (and future you) to read and understand, reducing those "bah humbug" moments during code reviews.

=head2 When Feeling Grateful ğŸ™

There are plenty of people who worked hard to make L<Ref::Util> possible, and they deserve a lot of credit:

=over 4

=item * Vikenty Fesunov

=item * Aaron Crane

=item * Gonzalo Diethelm

=item * Karen Etheridge

=item * Yves Orton

=item * Steffen MÃ¼ller

=item * Jarkko Hietaniemi

=item * Mattia Barbon

=item * Zefram

=item * Tony Cook

=item * Sergey Aleynikov

=back

=head2 A New Year's Resolution ğŸ¥‚

As we bid farewell to the old year and welcome the new, let's make a resolution to write cleaner, faster, and more maintainable Perl code. L<Ref::Util> is a wonderful tool to help us on that journey.

So, next time you find yourself writing C<ref $variable eq 'TYPE'>, remember there's a merrier way. Let L<Ref::Util> spread joy in your codebase, and may your days be merry and bright!

B<Happy Holidays and Happy Coding!>

I<May your CPU cycles be short and your code delights be plenty!> ğŸ‰

=cut
