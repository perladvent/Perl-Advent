Title: Growing Christmas Trees
Topic: SVG (and SVG::ChristmasTree)
Author: Dave Cross <dave@perlhacks.com>

=head1 Growing Christmas Trees

ElfName was in a bit of a panic. She had been given the job of producing a
series of designs for this year's North Pole Christmas cards and so far she
had made no progress. And the print deadline was approaching fast.

The problem was just too complex. It wasn't just a case of taking a mildly
embarrassing photo of the Clauses and then printing that on hundreds of cards.
No, Santa had decided that he didn't want a photo this year. He wanted cute
graphics of Christmas trees. Also (and this was the hard part), he wanted
dozens of different designs with different numbers of tree and tree of many
different sizes. There just wasn't time to create that many designs.

[ Invent silly situation which introduces Elf to the idea of SVG. ]

=head2 Two Types of Graphics

Most image files that we come across every day are B<raster> images. Basically,
the image is made up of a two-dimensional grid of points
(called B<picture elements> or B<pixels>). Each pixel is set to be a
particular colour and when we look at the complete set of coloured pixels, we
see it as an image.

Raster images are great for many uses. All of the JPG and PNG and GIF images
that you come across every say on the internet are raster images. But they
have a couple of downsides - one of which is that they don't scale very well.
When you view a raster image at the intended size, you don't see the
inidividual pixels. But as you scale up the image, there will come a point
where each pixel becomes large enough to be seen. Initially, you might notice
that a straight edge starts to look a bit jagged. Eventually, you'll see every
pixel and the image turns into an unrecognisable pile of squares.

Vector images are different. Vector images don't contain instructions saying
that "this pixel is red" or "that pixel is blue". They contain higher level
instructions like "draw a red circle with this radius, centred on this point".
And as you scale up the drawing area, those instructions remain just as valid.
You'll get a bigger circle, but one that is still drawn with sharp edges.

SVG (for "Scalable Vector Graphics") is an XML format for describing vector
graphic. It has become very popular on the web and many browsers now have
build-in support for displaying SVG images.

Not all images are suitable for being represented in the SVG format. As an
SVG image is made up of lots (possibly hundreds) of shapes, something like a
photo doesn't really work in this format. But if you can describe your image
in terms of the shapes that make it up, then it would be a good candidate for
being turned into an SVG document.

For example, a cartoon representation of a Christmas tree.

=head2 Varying the Design

But that only gets us part of the way there. ElfName needs to produce many
different designs of her Christmas tree. How does SVG help us there?

An SVG document isn't so much a description of an image. It's more of a recipe
that tells you how to produce the image. And when you have a recipe, it's easy
to vary parts of the recipe in order to vary the results we get out at the
end. So we need to write a program which generates various different Christmas
trees, depending on its input parameters. And, luckily, there is a CPAN module
called SVG which we can use to output SVG documents.

Let's think a little about what we need to draw a Christmas tree. I'm
planning on something like this:

[ insert image of tree ]

The main tree is four triangles. There's a brown rectangle at the bottom for
the trunk and, below that, a red trapezium for the pot. There are a number
of circles for baubles, and, finally, a star on top. All of these can be
described in terms of simple shapes and, therefore, can represented in SVG.

What variables might we want to alter.

=over 4

=item *

The number of triangles in the body of the tree.

=item *

The colour of the body of the tree

=item *

The length of the trunk.

=item *

The colour of the baubles and the star.

=back

(There are probably more that you can think of, but these will be enough to
solve Elfname's current problem.)

Elfname set to on this task and quickly managed to write code to draw some
shapes that looked like a tree. And then, she bundled the code up into a Moose
class which she uploaded to CPAN. Like most classes, this class starts by
loading Moose and defining some attributes. The most important attribute is the
one that contains the SVG object itself.

    has svg => (
      isa  => 'SVG',
      is   => 'ro',
      lazy_build => 1,
    );

    sub _build_svg {
      my $self = shift;

      return SVG->new(
        width => $self->width,
        height => $self->height,
      );
    }

Then there are a number of attributes that define the various characteristics
of the tree that we might want to change. Here are some examples:

    has layers => (
      isa => 'Int',
      is  => 'ro',
      default => 4,
    );

    has trunk_length => (
      isa => 'Str',
      is  => 'ro',
      default =>
    );

    has leaf_colour => (
      isa => 'Str',
      is  => 'ro',
      default => 'rgb(0,127,0)',
    );

There's a main driver method that actually draws the tree.

    sub as_xml {
      my $self = shift;

      $self->pot;
      $self->trunk;
      my $width = 600;
      my $tri_bottom = 700;
      for (1 .. $self->layers) {
        my $h = $self->triangle(90, $width, $tri_bottom);
        $self->bauble(500 - ($width/2), $tri_bottom);
        $self->bauble(500 + ($width/2), $tri_bottom);
        $width *= 5/6;
        $tri_bottom -= ($h * .5)
      }

      return $self->svg->xmlify;
   }

This just calls various lower-level methods which draw the inidividual shapes
that make up the tree before, finally, calling C<xmlify> on the SVG attribute
which actually produces the XML output that describes the tree.

As most of the parts of the tree are just coloured shapes, there's a method
called C<coloured_shape> which does most of that work.

    sub coloured_shape {
      my $self = shift;
      my ($x, $y, $colour) = @_;

      my $path = $self->svg->get_path(
        x => $x,
        y => $y,
        -type => 'polyline',
        -closed => 1,
      );

      $self->svg->polyline(
        %$path,
        style => {
          fill => $colour,
          stroke => $colour,
        },
      );
   }

This takes three arguments: an array of X points, an array of Y points and
a colour. It uses the C<SVG> modules, C<get_path> and C<polyline> methods to
turn the X and Y co-ordinates into an SVG polyline element which it then adds
to the SVG image.

Finally, one of the methods that uses C<coloured_shape> looks like this. This
is the C<pot> method (so notice that, currently, the co-ordinates are all
fixed values).

    sub pot {
      my $self = shift;
      $self->coloured_shape(
        [  400, 350, 650,  600 ],
        [ 1000, 800, 800, 1000 ],
        $self->pot_colour,
      );
    }
