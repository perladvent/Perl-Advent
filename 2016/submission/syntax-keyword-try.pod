Every year around this time Santa has some presents to deliver. And every
year, try as he might, sometimes things don't go very well. There's always
someone whose chimney is just too small for him to fit down, or the fire's
still lit, or maybe even someone doesn't have a chimney so he'll have to come
in the door like everybody else does.

If Santa is going to succeed at delivering as many presents as possible, he
can't just stop at the first failure. He'll have to carry on past those,
making as best an effort as possible.

In Perl, there's a number of ways we can handle failed attempts to call a
function. We could use C<eval>, though this has a number of non-ideal
properties and can lead to code that doesn't read very well. Better is to use
one of the CPAN modules that wrap this in some nicer syntax.

One nice module for doing this with is L<Syntax::Keyword::Try>, which provides
a neat syntax similar to that used by a number of other languages, being
marked by two new keywords C<try> and C<catch>:

 #!perl
 use Syntax::Keyword::Try 'try';

 sub attempt_delivery
 {
     my ( $present ) = @_;

     try {
         deliver_via_chimney( $present );
     }
     catch {
         print "We couldn't deliver it because $@";
     }
 }

 attempt_delivery( $_->present ) for
     grep { not $_->is_naughty } @children;

As compared to simple C<eval> syntax and checking the value of C<$@>
afterwards, we can see this looks a lot neater. Instead of looking at the
truth of C<$@> (which already is a buggy antipattern), or testing the truth
of the return value of C<eval> itself, we simply use the C<catch> keyword to
provide the code to handle a failure. Because it's using the syntax plugin
system, the keyword already acts like a full statement and not an expression,
so no semicolon is needed at the end of it.

So far our error handling hasn't been very good though, because all we did was
print that a failure happened. Perhaps we can do better. If Santa can't
deliver the present through the chimney, he'll just have to come in the door
instead.

 #!perl
 try {
     deliver_via_chimney( $present );
 }
 catch {
     try {
         deliver_via_door( $present );
     }
     catch {
         print "We couldn't deliver it at all, because $@";
     }
 }

A neater way to write this code, and more extensible in case we find even more
ways to deliver presents, is to use a C<return> statement inside a C<try>
block. This is another useful ability that C<Syntax::Keyword::Try> has that
regular C<eval> does not.

 #!perl
 my $failure;

 try {
     deliver_via_chimney();
     return;
 }
 catch { $failure //= $@ }

 try {
     deliver_via_door();
     return;
 }
 catch { $failure //= $@ }

 ...

 print "We couldn't deliver at all, because $failure";

We also now have the advantage that it's now the first failure message that
we print at the end. If one of the later attempts succeeds, it doesn't really
matter any more what the earlier failure was.

Well, to a point. It's not particularly nice to ignore any possible error,
because it could have been something unrelated - an unexpected type of data
passed in, a missing module dependency, all sorts of things.

Some languages have typed exceptions, but in Perl we generally make do with
string messages and testing them with regexps. If we C<die> an exception from
a catch block it re-throws it, effectively acting like we didn't catch it in
the first place.

 #!perl

 sub attempt_delivery
 {
     try {
         deliver_via_chimney();
         return;
     }
     catch {
         die $@ if $@ !~ m/^Cannot fit in the chimney/;
     }

     ...
 }
