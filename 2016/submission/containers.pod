Title: Using containers with Linux
Topic: Linux::Clone Linux::Unshare Linux::Setns
Author: Marian HackMan Marinov <mm@yuhu.biz>

=pod

Linux containers are a hot topic these days. This is why I chose to share with you, how you can work with containers using Perl.

Currently in Linux there are 5 namespace which allow a process:
* UTS - to have different hostname and domainname
* PID - to have its own view of the PIDs of the machine. This allows the process to create processes with PIDs that are already existing on the machine.
* NET - to see different, limited version of the network infrastructure of the kernel. As if the process has its own network.
* IPC - to have a separate SHM, SEM and MQ identifiers
* USER - to have separate user and group identifiers
* MOUNT - to see different view of the mounted filesystems

For the purpose of this article I will assume that a "container" is a processes or group of processes that has one or more namespaces different from the intial namespaces.

There are 3 modules for working with "containers":
=over
=item L<Linux::Clone> - to create a new container.
=item L<Linux::Unshare> - to create a new container without forking.
=item L<Linux::Setns> - to change your current container.
=back

=head2

So let's start with L<Linux::Clone>. This module is basically wrapper to the glibc L<call(2)> wrapper function. I will cover only the parts of it related to Linux namespaces. These are CLONE_NEWNET, CLONE_NEWPID, CLONE_NEWIPC, CLONE_NEWUTS, CLONE_NEWNS(mount namespace), CLONE_NEWUSER.

Namespaces are used to create isolated environment where your process have only limited access to the system.
For example if you want to make sure that only processes you have started can use the SHM you created, you can use Linux::Clone to create a new process with its own IPC namespace and after that create your SHM. This way you are both protecting your SHM from others on the machine and protecting everyone else from your process.

This is how the code will look in your Perl application:

    use Linux::Clone;
    use POSIX;
    
    sub child {
        print "In the child\n";
        system("ipcs");
    }
    Linux::Clone::clone sub { child; }, 0, Linux::Clone::NEWIPC || POSIX::SIGCHILD; 

=head2

If you don't want to create a new process, but you want to change some of the namespace in your current process you can use L<Linux::Unshare>. This module implements the glibc L<unshare(2)> wrapper function, which does exactly this.

    use Linux::Unshare qw(unshare CLONE_NEWIPC);
    
    unshare(CLONE_NEWIPC);
    system("ipcs");
		
=head2

However, usually you would not create containers directly from your application, but you probably would use something like LXC, LXD or Docker to create and mange your containers. So most likely what you would want to do is attach/enter into these containers.
For this you can use the L<Linux::Setns> module, that is wrapping the L<setns(2)> glibc function.

In order to identify a namespace you would use the files in /proc/PID/ns/{ipc,mnt,net,pid,user,uts}. With the setns function, you can join one or more of these namespaces or all of them. This way your process can actually enter in each namespace and do the rest of its work within the confines of that namespace.

    use Linux::Setns qw(setns CLONE_NEWIPC)

	setns("/proc/PID/ns/ipc", CLONE_NEWIPC);
	system("ipcs");

When you are entering a single namespace, L<setns(2)> requires that you give it a file descriptor from that precise namespace. So if we look at the example above, we are entering the IPC namespace (by using CLONE_NEWIPC) and we are supplying the path to the ipc file descriptor (/proc/PID/ns/ipc). If we were for example to enter the network namespace, we would use CLONE_NEWNET and /proc/PID/ns/net.

=head2

For any kind of container manipulation (creation or entering) you will need root (CAP_SYS_ADMIN) privileges.
