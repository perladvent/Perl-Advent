Title: Help Santa Klaus Reward Only Nice Children
Topic: modules
Author: Jerome Eteve <jerome.eteve@gmail.com>

=head2 Once Upon A Time

It's 2016, and near the North Pole in Scotland, Santa Klaus is having his annual
financial review. And it doesn't look great.

Santa realises he needs to reduce his costs from now on, and so decides to only
reward children who have been nice throughout the year, as opposed to lavishly
rewarding even the naughty ones as he's done for decades past.

After consulting with the senior elves, Santa decides to implement a child
niceness assessment process over the year:

=over

=item In February, all parents receive a letter from Santa including a report form for them to fill in.

=item The due date for the report form is the 1st of November.

=item If no form has been received, the child is considered naughty.

=item Each completed form is assigned to an elf for assessment (the assessment process is another story).

=back

Santa's elves are not very enthusiastic about implementing this in Perl. How can
they design their processes in order to minimize the mess? How can they unit
test this to make sure things don't randomly fail in the future?

'Stop panicking!' says Rudolf, head of Santa's programming sweatshop. 'I've
found L<Schedule::LongSteps> on the CPAN!'

L<Schedule::LongSteps> is a small framework that enables you to program the
future with confidence. Here's how to implement the form process the elves need.

=head1 Let's Implement

For this implementation, we'll assume we have an object C<$santaHQ> that
represents Santa's business and all the wonderful things it can do.

In L<Schedule::LongSteps>, a process is modelled simply as a class:

  package My::Process::NicenessFeedback;

  use Moose; # There are a lot of them in Santa's land.
  extends qw/Schedule::LongSteps/;

  # The required context:
  has 'santaHQ' => ( is => 'ro', isa => 'My::SantaHQ', required => 1 );

  __PACKAGE__->meta->make_immutable();
  1;

=pod

Each actual process is an instance of this that maintains a state. The state of
the process serves both as the place to give the process parameters and the
place that stores the current work in progress. It must only contain 'pure perl'
data, so no objects.

Because a process is about a child, we want to instantiate it like so:

  my $sl = Schedule::LongSteps->new();

  $sl->instantiate_process(
    'My::Process::NicenessFeedback',
    { santaHQ => $santaHQ },  # The context
    { child_id => 1234 }      # Initial state
  );

Then in the process:

  package My::Process::NicenessFeedback;
  ...
  has 'child' => ( is => 'ro', lazy_build => 1 );
  sub _build_child{
    my ($self) = @_;
    return $self->santaHQ()
                ->big_book_of_children
                ->find( $self->state()->{child_id} );
  }

The process now has a child, and so we can define what it should do first.
For this, we implement the (mandatory) method 'build_first_step':

  sub build_first_step{
      my ($self) = @_;
      # At the beginning of February next year
      # send the parents a form.
      return $self->new_step({
        what   => 'do_send_form_to_parents',
        run_at => DateTime->now()
                          ->add( year => 1 )
                          ->set_month(2)
                          ->truncate_to( to => 'month' )
      });
  }

Steps in the process are implemented as methods. The convention is to name them
with the prefix 'do_', to avoid any possible conflict with future methods.

  sub do_send_form_to_parents{
      my ($self) = @_;

      my $form = $self->santaHQ()
                      ->santas_pa()
                      ->create_niceness_form( $self->child() );

      $self->santaHQ()
           ->outbox()
           ->send_letter( $form, $self->child()->parental_address() );

      # The following November, we want to check stuff.
      return $self->new_step({
        what   => 'do_check_form_reception',
        run_at => DateTime->now()
                          ->set_month(11)
                          ->truncate_to( to => 'month' ),
        state  => {
           %{$self->state()},
           form_id => $form->id(),
        },
      });
  }

  has 'form' => ( is => 'ro', isa => 'My::Form', lazy_build => 1 );
  sub _build_form{
      my ($self) = @_;
      return $self->santaHQ()
                  ->forms_register()
                  ->find( $self->state()->{form_id} );
  }

  sub do_check_form_reception{
      my ($self) = @_;
      unless( $self->form()->is_back() ){
          # Oh no! The form was not received, and so the child is
          # considered naughty. This is the end of the process.
          $self->child->has_been_naughty_in( DateTime->now()->year() );
          return $self->final_step({
             state => {
                %{$self->state()},
                reason => 'Missed deadline'
             },
          });
      }

      # The form has been returned - time to pick an elf and start
      # the review process.
      my $reviewer_elf = $self->santaHQ()->most_available_elf();
      $self->longsteps()->instantiate_process(
        'My::Process::NicenessAssessment',
        { santaHQ => $self->santaHQ() },
        {
          child_id => $self->child()->id(),
          elf_id   => $reviewer_elf->id(),
          form_id  => $self->form()->id()
        },
      );

      return $self->final_step({
        state => {
          %{$self->state()},
          reason => 'Form received'
        }
      });
  }

'Wait, wait, wait,' says one of the elves. 'This is supposed to happen in the
future. How do we make sure today that this process will work?'

Well, this is where unit testing comes into play. Here's how to write a test:

  use Test::MockDateTime;
  my $longsteps = Schedule::LongSteps->new();

  my $january  = DateTime->now->set_month(1)->truncate( to => 'month' );
  my $february = DateTime->now->set_month(2)->truncate( to => 'month' );
  my $november = DateTime->now->set_month(11)->truncate( to => 'month' );

  my $p;
  on $january => sub{
    $p = $longsteps->instantiate_process(
      'My::Process::NicenessFeedback',
      { santaHQ => $santaHQ },
      { child_id => 1234 },
    );
  };

  my $form;
  on $february => sub{
      $longsteps->run_due_processes({ santaHQ => $santaHQ });
      $p = $longsteps->find_process( $p ); # Reload process.
      $form = $santaHQ->forms_register()->find( $p->state()->{form_id} );
      ok(
        $form->is_sent(),
        "Process should now have a form_id, and the form should be sent",
      );
  };

  # For this test, we assume the form was not sent back by November.
  on $november => sub{
      $longsteps->run_due_processes({ santaHQ => $santaHQ });
      my $child = $santaHQ->big_book_of_children
                          ->find( $p->state()->{child_id} );
      ok(
        $child->has_been_naughty(),
        "Child is marked as naughty",
      );
  };


'By Odin, Rudolf, this is jolly good,' Santa says enthusiastically. 'So I just
need to run C<$longsteps-E<gt>run_due_process()> from time to time?'

'That's right,' Rudolph replies. 'We'll put it in a cron job or an Event loop
watcher, and we're good to go. We don't even need to worry about concurrency, so
we can have as many machines as we want doing it.'

Santa looks thoughtful. 'And next year, maybe we can also use this to automate
the gift-returning procedure...'

=head2 Disclaimer

Of course there is no Santa Klaus, and this code has not been tested anywhere
other than Dreamland. But what is the future, if not our dreams come true?

=head2 See Also

L<BPM::Engine> A business process engine based on XPDL

=cut
