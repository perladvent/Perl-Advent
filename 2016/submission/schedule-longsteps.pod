Title: Help Santa Klaus Reward Only Nice Children
Topic: modules
Author: Jerome Eteve <jerome.eteve@gmail.com>

=head1 ONCE UPON A TIME

It's 2016, and near the North Pole in Scotland, Santa Klaus is having his annual financial review. And it doesn't look great.

Santa realises he needs to reduce his costs from now on, and so decides to only reward children who have been nice throughout the year,
as opposed to lavishly rewarding even the naughty ones as he's done for decades past.

After consulting with the senior elves, Santa decides to implement a child niceness assessment process over the year:

=over

=item In February, all parents receive a letter from Santa including a report form for them to fill in.

=item The due date for the report form is the 1st of November.

=item If no form has been received, the child is considered naughty.

=item Each completed form is assigned to an elf for assessment (the assessment process is another story).

=back

Santa's elves are not very enthusiastic about implementing this in Perl. How can they design their processes in order to minimize the mess? How can they unit test this to make sure things don't randomly fail in the future?

'Stop panicking!' says Rudolf, head of Santa's programming sweatshop. 'I've found L<Schedule::LongSteps> on the CPAN!'

L<Schedule::LongSteps> is a small framework that enables you to program the future with confidence. Here's how to implement the form process the elves need.

=head1 LET'S IMPLEMENT

For this implementation, we'll assume we have an object C<$santaHQ> that represents Santa's business and all the wonderful things it can do.

In L<Schedule::LongSteps>, a process is modelled simply as a class:

  package My::Process::NicenessFeedback;

  use Moose; # There are a lot of them in Santa's land.
  extends qw/Schedule::LongSteps/;

  # The required context:
  has 'santaHQ' => ( is => 'ro', isa => 'My::SantaHQ', required => 1 );

  __PACKAGE__->meta->make_immutable();
  1;

=pod

Each actual process is an instance of this that maintains a state. The state of the process serves both
as the place to give the process parameters and the place that stores the current work in progress. It must
only contain 'pure perl' data, so no objects.

Because a process is about a child, we want to instantiate it like so:

  my $sl = Schedule::LongSteps->new();

  $sl->instantiate_process( 'My::Process::NicenessFeedback', { santaHQ => $santaHQ }, # The context
                                                            { child_id => 1234 } # Initial state
                          );

Then in the process:

  package My::Process::NicenessFeedback;
  ...
  has 'child' => ( is => 'ro', lazy_build => 1 );
  sub _build_child{
    my ($self) = @_;
    return $self->santaHQ()->big_book_of_children->find( $self->state()->{child_id} );
  }

The process now has a child, and so we can define what it should do first.
For this, we implement the (mandatory) method 'build_first_step':

  sub build_first_step{
      my ($self) = @_;
      # At the beginning of February next year, send the parents a form.
      return $self->new_step({ what => 'do_send_form_to_parents',
                               run_at => DateTime->now()->add( year => 1 )->set_month(2)->truncate_to( to => 'month' )
                            });
  }

Steps in the process are implemented as methods. The convention is to name them with the prefix 'do_', to avoid any possible conflict
with future methods.

  sub do_send_form_to_parents{
      my ($self) = @_;
      my $form = $self->santaHQ()->santas_pa()->create_niceness_form( $self->child() );
      $self->santaHQ()->outbox()->send_letter( $form, $self->child()->parental_address() );
      # The following November, we want to check stuff.
      return $self->new_step({ what => 'do_check_form_reception',
                               run_at => DateTime->now()->set_month(11)->truncate_to( to => 'month' ),
                               state => { %{$self->state()} , form_id => $form->id() }
                           });
  }

  has 'form' => ( is => 'ro', isa => 'My::Form', lazy_build => 1 );
  sub _build_form{
      my ($self) = @_;
      return $self->santaHQ()->forms_register()->find( $self->state()->{form_id} );
  }

  sub do_check_form_reception{
      my ($self) = @_;
      unless( $self->form()->is_back() ){
          # Oh no! The form was not received, and so the child is considered naughty.
          # This is the end of the process.
          $self->child->has_been_naughty_in( DateTime->now()->year() );
          return $self->final_step({ state => { %{$self->state()} , reason => 'Missed deadline' } });
      }

      # The form has been returned - time to pick an elf and start the review process.
      my $reviewer_elf = $self->santaHQ()->most_available_elf();
      $self->longsteps()->instantiate_process( 'My::Process::NicenessAssessment', { santaHQ => $self->santaHQ() },
                                               { child_id => $self->child()->id(),
                                                 elf_id   => $reviewer_elf->id(),
                                                 form_id => $self->form()->id()
                                             });
  }

'Wait, wait, wait,' says one of the elves. 'This is supposed to happen in the future. How do we make sure today
that this process will work?'

Well, this is where unit testing comes into play. Here's how to write a test:

  use Test::MockDateTime;
  my $longsteps = Schedule::LongSteps->new();

  my $january = DateTime->now()->set_month(1)->truncate( to => 'month' );
  my $february = DateTime->now()->set_month(2)->truncate( to => 'month' );
  my $november = DateTime->now()->set_month(11)->truncate( to => 'month' );

  my $p;

  on $january => sub{
      $p = $longsteps->instantiate_process( 'My::Process::NicenessFeedback', { santaHQ => $santaHQ },
                                            { child_id => 1234 }
                                          );
  };

  my $form;
  on $february => sub{
      $longsteps->run_due_processes({ santaHQ => $santaHQ });
      $p = $longsteps->find_process( $p ); # Reload process.
      $form = $santaHQ->forms_register()->find( $p->state()->{form_id} );
      ok( $form->is_sent(), "Process should now have a form_id, and the form should be sent" );
  };

  # For this test, we assume the form was not sent back by November.
  on $november => sub{
      $longsteps->run_due_processes({ santaHQ => $santaHQ });
      my $child = $santaHQ->big_book_of_children->find( $p->state()->{child_id} );
      ok( $child->has_been_naughty() , "Child is marked as naughty" );
  };


'By Odin, Rudolf, this is jolly good,' Santa says enthusiastically. 'So I just need to run
C<$longsteps-E<gt>run_due_process()> from time to time?'

'That's right,' Rudolph replies. 'We'll put it in a cron job or an Event loop watcher, and we're good to go.
We don't even need to worry about concurrency, so we can have as many machines as we want doing it.'

Santa looks thoughtful. 'And next year, maybe we can also use this to automate the gift-returning procedure...'

=head1 DISCLAIMER

Of course there is no Santa Klaus, and this code has not been tested anywhere other than Dreamland.
But what is the future, if not our dreams come true?

=head1 SEE ALSO

L<BPM::Engine> A business process engine based on XPDL

=cut
